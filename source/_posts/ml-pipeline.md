---
title: 机器学习的建模流程和Pipeline搭建
date: 2021-12-28
updated: 2021-12-28
categories:
- 机器学习
tags:
- pipeline
keywords: 机器学习流程,机器学习,管道,Pipeline,定义问题,数据收集和整合,预处理和可视化数据,模型训练和优化,模型评估,模型部署
description: 本文梳理机器学习管道，从一个业务问题开始，分别讲解定义问题、数据收集和整合、预处理和可视化数据、模型训练和优化、模型评估和模型部署环节的主要工作和关键技术。
---

## 机器学习
### 经典编程方法 VS 机器学习方法
业务需求：购物网站产品推荐，假设您需要创建一款后端应用程序，使其根据客户过去的购买记录向他们推荐产品。

**经典编程**：根据数据（输入）进行预测（输出），需要对数据应用一些规则，在经典编程中，这些规则由人根据业务需求和领域知识等因素制定。

**机器学习**：利用过去收集的各种数据,自动推导出数据中隐藏的模式。然后,利用模式创建模型,应用于新数据,从而提供更明智的自适应预测。

![机器学习VS经典编程](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281403309.png)

### 什么是模型？
机器学习中的模型是指经过训练的算法，用于识别数据中的模式。关键在于，他是通过机器学习过程来训练的，而不像经典编程一样，是由编程人员通过设置规则手动创建的。

### ML管道
![机器学习管道](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112220844576.jpg)

- **业务问题**：需要确定能够从机器学习中受益的业务问题。
- **定义问题**：需要理清业务问题并将其转化为机器学习问题。
- **数据收集和整合**：确保原始数据位于一个集中且易于访问的地方。
- **预处理和可视化数据**：将原始数据转换为易于理解的格式并从数据中提取重要特征。
- **模型训练和优化**：这是一个迭代的过程，可以在整个工作流程中多次执行。刚开始模型可能不会产生期望的结果，需要设计更多特征并优化模型超参数，然后重新训练。
- **模型评估**：持续的进行模型训练和优化，直到模型的评估结果显示模型的性能符合业务案例的要求。如果模型不符合业务目标，则需要重新评估一些东西，再次审视一下数据和特征，寻找改进模型的方法。
- **模型部署**：如果对训练结果感到满意，就可以部署模型来交付最佳预测结果，这通常是一项繁重的体力劳动。


## 问题定义
![问题定义](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281301865.jpg)
问题定义是管道中研究性阶段，是对需要解决的问题进行分析和定义的过程。这项工作是所有ML项目的起始点，因为我们需要充分确定某个问题，才能制造确定出相应的解决方案。

### 确定问题
示例：某些产品库存挤压，某些产品库存不足，分别导致开销增加和错过销售机会。
- 业务问题：需求预测不准确，让企业蒙受损失。
- 业务目标：减少未销售的库存的数量，同时不因库存不足而错过销售机会。
- 成功指标：每月月底未销售出的库存不超过15%，同时不存在库存不足的问题。

确定问题在业务方面的信息后，接下来需要确定使用那种ML模型。
我们要预测每种产品的具体销量，因此这最有可能是一种回归问题。

### 确定成功标准
- **模型效果指标**
  - 在ML管道的测试和评估环节使用
  - 一般通过准确性来体现
- **业务目标指标**
  - 在**部署**模型后使用
  - 衡量模型在**真实环境**中的效果
  - 可以识别出**不当的模型效果指标**

## 数据收集和整合
![数据收集和整合](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281302881.jpg)
### 选择数据
- **了解数据**：有多少数据，位于哪里，数据量，数据位置以及可否访问。
- **寻找领域专家**：是否拥有解决问题**所需的数据**？数据是否有**代表性**？
- **评估数据质量**：好的数据会包含与我们希望预测的现象有关的信号，是否具有足够的特征和标签。

### 数据湖
了解了你需要的数据以后，现实场景中，机器学习项目的数据来自多个数据源，并呈现为不同类型的数据，包括结构化、半结构化和非结构化的数据。例如数据可以来自CSV文件和传统数据库。

当数据以不同格式存储在各个不同的位置时,组织经常会面临访问和分析其数据的挑战。随着数据不断收集自各种来源,如果不能妥善处理,这一挑战只会随着组织的成熟和发展而变得越来越严峻。无法轻松访问数据会导致工作流程出现瓶颈,因为员工经常需要向IT部门寻求帮助,以访问构建、训练和部署机器学习模型所需的信息。为了应对这些挑战,组织不得不寻求这样一种解决方案:**能够提供单一数据来源,让员工能够随时根据需要轻松访问数据。** 本地解决方案通常很难做到这一点,而且维护成本很高。

![数据湖](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112230809278.png)
数据湖架构可以提供一个坚实的基础,用于构建解决方案应对这一挑战。借助数据湖, 可以将大量数据存储在一个集中存储库,以便组织内的各个团队随时对其进行分类、处理、扩充和使用。
但是,建立数据湖并没有什么灵丹妙药。在大多数情况下,构建数据湖需要使用多种 技术、工具和环境,包括来自第三方的数据。如果操作正确,数据湖将为全新的高级 分析方法打开一扇大门,从而推动数据科学和机器学习。

## 数据预处理和可视化
![数据预处理和可视化](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281303539.jpg)
### 重新格式化数据
- **Pandas**：Pandas 是一个开源 Python 库,可用于重新格式化特定数据。Pandas 将 CSV、JSON、 Excel、Pickle 等各种格式的数据重新格式化为表格形式,以行和列的形式呈现出来。Pandas将数据格式化后得出的表格格式称为DataFrame，可以进行计算统计信息，清理数据，对其进行可视化，甚至将清理或转换后的数据重新以其原始格式存储。
- **NumPy**:NumPy是一个Python库,可在与 Python 搭配使用进行科学计算时用作基础 软件包。这是一个通用的数组处理程序包,可提供高性能的多维数组对象以及用于处理这些数组的工具。
- **Scikit-learn**:Scikit-learn是一个开源Python库,其中包括用于数据挖掘和数据分析的 各种工具。它基于NumPy、SciPy 和Matplotilb库而构建,可用于机器学习管道的每个阶段,包括数据预处理。我们将在管道的模型训练阶段回过头来学习Scitkit,因为该库包含了线性回归和随机森林等监督算法,以及集群和K-means等非监督算法。
- **Matplotlib**:Matplotlib 是 Python 中的可视化库,用于NumPy数组的二维图。借助 Matplotlib,您可以通过多种方式可视化数据,其中包括线形图和条形图、散点图和直方图。您可以直接在 Python 脚本、Jupyter笔记本、iPython Shell 和其他平台中利用该库。
- **Seaborn**:Seaborn 是另一个Python数据可视化库。它基于Matplotlib构建,并与Pandas DataFrame紧密集成。它提供了一个高级界面,可绘制有吸引力且内容丰富的统计图形。

### 数据预处理
数据会出现多种形式混乱
- 算法希望看到使用英语编写的数据，但数据中的有些单词使用了其他语言
- 某些单词中包含特殊字符，单词之间有多个空格，大小写混用。
- 数据有多个不同的数据单位，比如公里、米、英尺混用。
- 因为录入问题，某列中包含其他列中的数据。

#### 异常值
产生异常值的原因：
- **自然的异常值** 不是人为的错误结果，而是反应了数据中的一些事实。
- **人为错误的异常值** 数据输入错误，以及其他错误类型。

处理异常值的方法：
- **删除异常值**:这种方法特别适合在人为错误导致异常值的情况下使用。
- **转变异常值**:您可以通过取一个值的自然对数进行这一操作,这将减少由极端异 常值引起的变化,从而减少异常值对整个数据集的影响。
- **为异常值输入新值**:例如,您可以使用特征的平均值,然后输入该值以替换异常值。同样,如果异常值是由人为错误引起的,那么这种方法非常合适。

#### 缺失值
由于数据收集错误,数据集中的某些列可能会缺失数据,或者直到进入数据收集过程之前才收集具有特定特征的数据。缺失数据会导致很难准确解读相关特征和目标变量之间的关系,因此,无论数据到底是怎么缺失的,处理这一问题都很重要。

缺失几个值可能不是问题,但如果一列中缺失的值过多,您可能会发现很难解读该特 征和目标(与模型需要预测的内容对应的该行中的值)之间的关系。

**缺失值统计**
pandas检查确实值或者NULL值
- 检查**每一列**有多少缺失值：df.isnull().sum()
- 检查**每一行**有多少缺失值：df.isnull().sum(axis=1)


**缺失值处理**
- **替换缺失值**：如果缺失值在整个数据集中随机分布，可能是由于数据捕获机制出现故障，并不代表其相应行或列的大部分，因为数据在很大程度是随机缺失的。这种情况下，替换是更好的选择。
  - 离散特征：使用出现最频繁的值来替换
  - 连续特征：使用平均值或者中位数来替换
- **删除缺失值**：如果列或者行的缺失占很大比例，则优先考虑删除整个行或列，而不是替换。
  - 删除行的风险：a.训练数据不足，过拟合。b.可能会偏向样本
  - 删除列的风险：可能会丢失特征中的信息，欠拟合。

### 数据可视化
#### 分类数据可视化
使用条形图可视化分类数据
``` python
speed = [0.1, 17.5, 40, 48, 52, 69, 88]
lifespan = [2, 8, 70, 1.5, 25, 12, 28]
index = ['snail', 'pig', 'elephant',
         'rabbit', 'giraffe', 'coyote', 'horse']
df = pd.DataFrame({'speed': speed,
                   'lifespan': lifespan}, index=index)
ax = df.plot.bar(rot=0)
```
![条形图](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112252018884.png)

#### 数值数据可视化

**直方图**
使用直方图进行数据可视化时会对值进行分箱，直方图中较高的峰值表示最常见的值。
``` python
df = pd.DataFrame({
    'length': [1.5, 0.5, 1.2, 0.9, 3],
    'width': [0.7, 0.2, 0.15, 0.2, 1.1]
    }, index=['pig', 'rabbit', 'duck', 'chicken', 'horse'])
hist = df.hist(bins=3)
```
![直方图](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112252017101.png)

**密度图**
密度图展示了单个特征的分布，密度图类似于直方图，但它使用核密度函数展示了平滑版的直方图密度。
``` Python
s = pd.Series([1, 2, 2.5, 3, 3.5, 4, 5])
ax = s.plot.kde()
```
![密度图](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112252020274.png)

**箱线图**
箱线图使用四分位间距来描绘特征的分布。
``` Python
data = np.random.randn(25, 4)
df = pd.DataFrame(data, columns=list('ABCD'))
ax = df.plot.box()
```
![箱线图](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112252028029.png)

#### 属性之间的关系
对于具有多个变量或特征的情况,您可能需要查看它们之间的相关性。确定属性之间 的相关性很重要,因为两个属性之间的高相关性有时会导致模型性能较差。如果特征 之间密切相关,并且全都用于同一个模型中以预测响应变量,就可能会出现问题,例 如,模型损失不能收敛到最小状态。因此,请注意数据集中高度相关的特征。

**散点图和散点图矩阵**
``` Python
df = pd.DataFrame([[5.1, 3.5, 0], [4.9, 3.0, 0], [7.0, 3.2, 1],
                   [6.4, 3.2, 1], [5.9, 3.0, 2]],
                  columns=['length', 'width', 'species'])
ax1 = df.plot.scatter(x='length',
                      y='width',
                      c='DarkBlue')
```
![散点图](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112252033581.png)

``` Python
df = pd.DataFrame(np.random.randn(1000, 4), columns=['A','B','C','D'])
pd.plotting.scatter_matrix(df, alpha=0.2)
```
![散点图矩阵](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112252035865.png)

**相关性矩阵热图**
numpy.corrcoef 计算相关性矩阵，使用Matplotlib或者Seaborn进行可视化。
![相关性矩阵热图](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112252041244.png)

## 模型训练和优化
![模型训练和优化](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281304798.jpg)
在训练过程中,机器学习算法会更新一组称为参数或权重的数字。目标是更新模型中 的参数,使计算或预测的输出尽可能接近真实的输出(就像在数据中看到的一样)。

一次迭代无法完成,因为算法还没有学会;它不知道改变权重会如何使输出更接近期望值。因此,它会观察之前迭代中的权重和输出,使权重降低生成的输出的误差。执 行完定义的迭代次数后或当误差变化低于目标值时,此迭代过程将会停止。

如果输出误差随着每次连续迭代逐渐减小,则我们可以说该模型已收敛,训练成功。 但如果误差在迭代之间增大或随机变化,则需要重新评估构建模型时的假设。

![模型训练过程](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112261107474.png)

### 数据拆分
对数据进行预处理之后，就可以开始训练了。首先需要确定拆分数据的最佳方式，一般而言，机器学习目标是构建一个泛化能力较强的模型。换句话说，模型不仅要能处理已知数据，还要能处理未知数据。因此拆分数据很重要。

拆分数据有助于确保数据块有资格成为未来的生成数据，还有助于保证模型预测未知数据的准确率和预测已知数据的准确率类似。这有助于提高模型的泛化能力。

测试和验证方法
- **简单留出验证**：将数据拆分为多个数据集，通常为训练集、验证集和测试集。
![简单留出验证](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112260724131.png)
- **K折交叉验证**：把数据集分成K份，每个子集互不相交且大小相同，依次从K份中选出1份作为验证集，其余K-1份作为训练集，这样进行K次单独的模型训练和验证，最后将K次验证结果取平均值，作为此模型的验证误差。
![K折交叉验证](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112261104698.png)
- **留一交叉验证**：测试集是一个数据点，适用于**非常小**的数据集
- **分层K折交叉验证**：训练集和测试集平衡类别分布，适用于**不平衡**的数据。
- **打乱数据的迭代K折验证**

### 损失函数
模型训练的目标是创建一个准确的模型，让他根据需求正确地解答业务问题。

损失函数用来评价模型的预测值和真实值不一样的程度，损失函数越好，通常模型的性能越好。不同的模型用的损失函数一般也不一样。

损失函数分为经验风险损失函数和结构风险损失函数。经验风险损失函数指预测结果和实际结果的差别，结构风险损失函数是指经验风险损失函数加上正则项。

![损失函数](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112261818366.png)

### 优化器
![梯度下降](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112261822292.png)

- **批量梯度下降法（Batch Gradient Descent）**：批量梯度下降法，是梯度下降法最常用的形式，具体做法也就是在更新参数时使用所有的样本来进行更新，
- **随机梯度下降法（Stochastic Gradient Descent）**：随机梯度下降法，其实和批量梯度下降法原理类似，区别在与求梯度时没有用所有的m个样本的数据，而是仅仅选取一个样本j来求梯度。
- **小批量梯度下降法（Mini-batch Gradient Descent）**：小批量梯度下降法是批量梯度下降法和随机梯度下降法的折衷，也就是对于m个样本，我们采用x个样子来迭代，1<x<m。一般可以取x=10，当然根据样本的数据，可以调整这个x的值。


**步长/学习速率**
步长的大小至关重要,因为步长较大可能会导致模型超过最低点,从而使模型来回摆动,永远不会达到最小值。但是,步长较小可能会导致模型非常缓慢地朝着最小值移动,在给定时间内无法达到最小值。步长大小又称“学习速率”,它是模型的超参数。

## 模型评估
![模型评估](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281304583.jpg)
### 过拟合和欠拟合
![过拟合和欠拟合](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112270845483.png)

- **欠拟合**是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。
-  **过拟合**是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，模型在训练集上表现很好，但在测试集上却表现很差。模型对训练集"死记硬背"，没有理解数据背后的规律，泛化能力差。

![过拟合和欠拟合](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112270848369.png)

**解决方案**
- **欠拟合**
  - 增加模型复杂度
  - 增加模型的特征
- **过拟合**
  - 正则化（Regularization）（L1和L2）
  - 数据扩增，即增加训练数据样本
  - Dropout
  - Early stopping

### 方差和偏差
- **偏差**：预测值于真实值之间的差距，即学习算法的拟合能力。
- **方差**：预测值的分散程度，训练集与验证集的差异造成的模型表现的差异。

![方差和偏差](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112270851712.png)

|        | 低偏差  | 高偏差  |
|  ----  | ----  | ----  |
| **低方差**  | 射手很稳，枪的准星也很准。 | 射手很稳，但是枪的准星有问题，所有子弹都固定地偏向一侧。 |
| **高方差**  | 射手不太稳，但枪的准星没问题，虽然弹着点分布很散，但没有整体偏移。 | 射手不稳，而且枪的准星也有问题，弹着点分布很散且有规律地偏向一侧。|

![偏差和方差](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112270900432.png)

我们希望偏差与方差越小越好，但实际并非如此。一般来说，偏差与方差是有冲突的，称为**偏差-方差窘境 (bias-variance dilemma)**。
- 给定一个学习任务，在训练初期，由于训练不足，网络的拟合能力不够强，偏差比较大，也是由于拟合能力不强，数据集的特征也无法使网络产生显著变化，也就是欠拟合的情况。
- 随着训练程度的加深，网络的拟合能力逐渐增强，训练数据的特征也能够渐渐被网络学到。
- 充分训练后，网络的拟合能力已非常强，训练数据的微小特征都会导致网络发生显著变化，当训练数据自身的、非全局的特征被网络学到了，则将发生过拟合。

### 评估指标
#### 分类问题指标
![混淆矩阵](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112270937734.png)
标签解释
- **P**：样本数据中的正例数。
- **N**：样本数据中的负例数。
- **Y**：通过模型预测出来的正例数。
- **N**：通过模型预测出来的负例数。

组合解释
- **真阳性**:True Positives，表示实际是正样本预测成正样本的样本数，真实为1，预测也为1。
- **假阳性**:False Positives，表示实际是负样本预测成正样本的样本数，真实为0，预测为1。
- **假阴性**:False Negatives，表示实际是正样本预测成负样本的样本数，真实为1，预测为0。
- **真阴性**:True Negatives，表示实际是负样本预测成负样本的样本数，真实为0，预测也为0。

计算公式
- **准确率Accuracy**:分类模型总体判断的准确率(包括了所有class的总体准确率)。$\text { Accuracy }=\frac{T P+T N}{T P+T N+F P+F N}$
- **精确率Precision**: 预测为1的准确率。 $\text { Precision }=\frac{T P}{T P+F P}$
- **召回率ReCall**：真实为1的准确率。$\text { Recall }=\frac{T P}{T P+F N}$
- **F1**：对于某个分类，综合了Precision和Recall的一个判断指标，F1-Score的值是从0到1的，1是最好，0是最差。$F_{1} \text { Score }=\frac{2 * \text { Precision } * \text { Recall }}{\text { Precision }+\text { Recall }}$
- **AUC-ROC**：反映的是对于任意一对正负例样本,模型将正样本预测为正例的可能性大于将负例预测为正例的可能性的概率。

#### 回归问题指标
- **均方差**
Mean Squared Error叫做均方误差,用真实值-预测值,然后平方之后求和平均。
$$\mathrm{MSE}=\frac{1}{m} \sum_{i=1}^{m}\left(y_{i}-\hat{y}_{i}\right)^{2}$$

- **R平方**
Coefficient of Determination，也叫R Squared，翻译为拟合系数。其定义是，对于某个变量$y_i$有一系列观测值$y_i$（比如某个区域的100套房子价格），和对应的预测值$\hat{y}_{i}$（比如根据房型和面积预测出的房子价格
$$R^{2}=1-\frac{\sum_{i}\left(\hat{y}_{i}-y_{i}\right)^{2}}{\sum_{i}\left(y_{i}-\bar{y}\right)^{2}}$$
其中， $\bar{y}$是100套房子的平均价格。
R方的含义是，该预测模型解释了变量的方差的比例。方差衡量的是变量取值的分散程度或者波动范围，方差越小，说明变量值波动越小，换言之，变量的取值越容易被预测和猜中。假设R方=0.8，则说明拟合之后，变量的方差减小了80%，则变量的取值更容易被确定。比如，我们需要对房子进行估价，采用房型和面积对房子价格进行拟合之后，发现房屋价格的方差减小了80%，那么我们更容易得到房子价格的准确估计。

## 特征设计和模型优化
![特征设计和模型优化](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281305843.jpg)

特征工程是从现有数据中提取更多信息，以便提高模型的预测能力和学习速度的一门科学。在特征工程中，我们不会添加任何新的数据，而是让已有的数据发挥更大的作用。这一过程往往需要依靠数据领域的知识才能设计更有效的特征。

**特征抽取**和**特征选择**是DimensionalityReduction（降维）的两种方法。

**维数灾难**：当维数增大时，空间数据会变得更稀疏，这将导致bias和variance的增加，最后影响模型的预测效果。
![维数灾难](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112280738673.png)

### 特征抽取
**特征抽取**:从现有特征中创建新特征来自动降低数据集中维数的过程，特征抽取后的新特征是原来特征的一个映射。
Feature Extraction: Creatting a subset of new features by combinations of the exsiting features

- **目的**：减少特征数据集中的属性(或者称为特征)的数目，DimensionalityReduction（降维）
- **手段**：通过属性间的关系，如组合不同的属性得新的属性，这样就改变了原来的特征空间

![特征抽取](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281042712.png)

### 特征选择
**特征选择**:根据预测的重要性对现有属性进行排序，然后选择最相关的属性。特征选择后的特征是原来特征的一个子集。
Feature Selection: Choosing a subset of all the features(the ones more informative)

- **目的**：减少特征数据集中的属性(或者称为特征)的数目，DimensionalityReduction（降维）
- **手段**：从原始特征数据集中选择出子集，是一种包含的关系，没有更改原始的特征空间。

![特征选择](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281044198.png)

### 特征创建和转换
于特征提取和特征选择不同，特征创建和转换不是一个减少维数的方法，相反，**特征创建和转换是从现有特征中生成新特征的过程。**

举个例子，加入我们将日期作为一个特征，其格式为两位数日期、两位数月份和两位数年份（日日-月月-年年），我们发现，将日期、月份和年份整合成一项特征对预测并没有太大帮助。相反，我们可以生成三项不同的特征，分别对应着日期，月份和年份，进而可能会发现其中某项特征和目标之间存在着有用的关系。

#### 数值数据
- 对数转换
- 平方或立方
- 分箱
- 缩放
  - 均值/方差标准化$x_{i, j}^{*}=\frac{x_{i, j}-\mu_{j}}{\sigma_{j}}$
  - 最大最小缩放 $x_{i, j}^{*}=\frac{x_{i}-\min x_{j}}{\max x_{j}-\min x_{j}}$
  - 最大绝对值缩放 $x_{i, j}^{*}=\frac{x_{i, j}}{\max \left(\left|x_{j}\right|\right)}$
  - 稳健缩放 $x_{i}^{*}=\frac{x_{i}-Q_{25}(x)}{Q_{75}(x)-Q_{25}(x)}$
  - 归一化

#### 分类数据
- 顺序：分类区分顺序，将定序变量中不同分类定义相对差值。
- 名目：分类不区分顺序，采用独热码进行编码。

### 模型优化-超参优化
#### 超参的三种类型
![超参数的类型](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281109739.png)
- **模型超参数**：可以帮助定义模型本身。例如,某些基于神经网络的模型需要我们在开始训练前先定义一个架构。这个架构会包含神经网络中特定数量的层,以及在其中使用的激活函数。以处理计算机视觉问题的神经网 络为例,我们需要定义架构的其他属性,例如筛选器大小、池化、步长和填充。
- **优化器超参数**：与模型如何根据数据来确定模式相关,用于神经网络模型。这种类型的超参数包含梯度下降和随机梯度下降等优化器。还可以包含Adam等使用动量的优化器,或者使用Xavier初始化或He初始化等方法将参数权重初始化的优化器。
- **数据超参数**：与数据本身的属性相关。这些属性包括定义不同的数据扩增方法(例如用于图像相关问题的裁剪或大小调整)的属性。这种参数一般在没有足够数 据或数据中没有足够变量时使用。

#### 超参的优化类型
- 网格搜索（grid search）是超参数优化的传统方法，是对超参数组合的子集进行穷举搜索，找到表现最佳的超参数子集。
- 随机搜索（random search），是对超参数组合的子集简单地做固定次数的随机搜索，找到表现最佳的超参数子集。对于规模较大的参数空间，采用随机搜索往往效率更高。
- 贝叶斯优化(Bayesian Optimization) 与网格/随机搜索最大的不同，在于考虑了历史调参的信息，使得调参更有效率。（但在高维参数空间下，贝叶斯优化复杂度较高，效果会近似随机搜索。）
![网格搜索和随机搜索](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281118708.png)
![贝叶斯优化](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281120191.png)

## 模型部署
![模型部署](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281305005.jpg)
模型部署指的是将模型及其资源集成到一个生产环境中，用于创建预测。

### 生产环境基础设置
![生产环境基础设施](https://imzhanghao.oss-cn-qingdao.aliyuncs.com/img/202112281127053.png)

### 推理类型
#### 批处理
- 模型在批量预测时可用
- 推理分批进行
- 数据集有多个行
- 作业完成后按计划获取结果
#### 实时
- 模型始终可用
- 推理实时进行
- 对数据进行单次观察
- 用户交互时可实时获得结果

### 推理VS训练
推理是使用经训练的模型进行推断或预测测试样本的阶段,它与训练一样,包括用于预测值的前向传递。与训练不同的是,它不包括用于计算误差和更新权重的反向传递。

|  推理   | 训练  |
|  ----  | ----  |
| 通常在单个输入上实时进行  | 需要高并行度和大规模批处理能力，以提高吞吐量 |
| 非计算/内存密集型  | 计算/内存密集型 |
| 集成到应用程序推展工作流程   | 独立，未集成到应用程序堆栈  |
| 在边缘和云中的不同设备上运行   | 在云中运行  |
| 持续运行   |  运行频率通常较低（只训练一次，不经常训练） |

### 监控
监控预测的性能并触发告警从而采取进一步的行动，它对模型的进化至关重要。
监控关键的特征变化也很重要。

## 参考资料
- [The Machine Learning Pipeline on AWS (Simplified Chinese)](https://www.aws.training/Details/InstructorLedTraining?id=89189)
