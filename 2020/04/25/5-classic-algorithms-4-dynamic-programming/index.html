<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="keywords" content="动态规划, 最长公共子串LCS, 最长递增子序列LIS, 最大连续子序列之和, 01背包问题, 青蛙跳台阶问题, 收集苹果, 数塔取数问题, 免费馅饼问题"><meta name="description" content="动态规划是面试中最经常考到的问题，它是功过拆解问题，定义问题状态和状态之间的关系，是的问题能够用递推的方式来解决。本文讲解动态规划的概念、基本思路，以及在经典问题中的实际应用，配合代码，直观明了。"><meta name="author" content="ZhangHao"><meta name="viewport" content="width=device-width, initial-scale=0.5"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title>五大经典算法|4.动态规划 - 张浩在路上</title><link rel="icon" href="/img/favicon.ico"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="dns-prefetch" href="https://hm.baidu.com"><script src="https://www.googletagmanager.com/gtag/js?id=UA-166608124-1" async=""></script><script>if (window.location.hostname !== 'localhost') {
  window.dataLayer = window.dataLayer || [];
  function gtag(){ dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-166608124-1');
}</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?0c64a5657309290fd8f5efe33fcbcdb4';
  hm.async = true;

  var s = document.getElementsByTagName('script')[0];
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/header.css"><link rel="icon" href="/img/favicon.png"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="张浩在路上" type="application/atom+xml">
</head><body>　　<nav class="navbar navbar-default navbar-fixed-top" style="opacity:.9;" role="navigation"><div class="container-fluid"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/" _blank>张浩在路上</a></div><div class="navbar-collapse collapse" id="bs-example-navbar-collapse-1" style="height:1px;"><ul class="nav navbar-nav navbar-right"><li><a href="/" target="_self">首页</a></li><li><a href="/technology" target="_self">技术</a></li><li><a href="/monetization" target="_self">变现</a></li><li><a href="/thinking" target="_self">思考</a></li><li><a href="/about" target="_self">关于</a></li></ul></div></div></nav><div class="inner"><h1>五大经典算法|4.动态规划</h1><div id="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"> 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text"> 思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text"> 经典例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text"> 最长公共子串(LCS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text"> 最长递增子序列(LIS)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text"> 最大连续子序列之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.4.</span> <span class="toc-text"> 01背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.5.</span> <span class="toc-text"> 青蛙跳台阶问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.6.</span> <span class="toc-text"> 收集苹果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.7.</span> <span class="toc-text"> 数塔取数问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.8.</span> <span class="toc-text"> 免费馅饼问题</span></a></li></ol></li></ol></div><p>动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推(或者说分治)的方式去解决。</p>
<p>经典例题: 最长公共子串LCS, 最长递增子序列LIS, 最大连续子序列之和, 01背包问题, 青蛙跳台阶问题, 收集苹果, 数塔取数问题, 免费馅饼问题</p>
<h2><span id="概念"> 概念</span></h2>
<p>dynamic programming is a method for solving a complex problem by breaking it down into a collection of simpler subproblems.</p>
<p>动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推(或者说分治)的方式去解决。</p>
<h2><span id="思想"> 思想</span></h2>
<p>动态规划算法的有效性依赖于待求解问题本身具有的两个重要性质：最优子结构性质和子问题重叠性质。</p>
<ul>
<li>1.最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质(即满足最优化原理)。最优子结构性质为动态规划算法解决问题提供了重要线索。</li>
<li>2.子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简 单地查看一下结果，从而获得较高的解题效率。</li>
</ul>
<p>当我们已经确定待解决的问题需要用动态规划算法求解时，通常可以按照以下步骤设计动态规划算法：</p>
<ul>
<li>1.分析问题的最优解，找出最优解的性质，并刻画其结构特征；</li>
<li>2.递归地定义最优值；</li>
<li>3.采用自底向上的方式计算问题的最优值；</li>
<li>4.根据计算最优值时得到的信息，构造最优解。</li>
</ul>
<p>1 ～ 3 步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤就可以了。如果问题需要构造最优解，还要执行第 4 步； 此时，在第 3 步通常需要记录更多的信息，以便在步骤 4 中，有足够的信息快速地构造出最优解。</p>
<h2><span id="经典例题"> 经典例题</span></h2>
<h3><span id="最长公共子串lcs"> 最长公共子串(LCS)</span></h3>
<p>一个序列 S,如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。</p>
<p>转移方程：</p>
<p>dp[i,j] = 0                               IF:   i=0 || j=0</p>
<p>dp[i,j] = dp[i-1][j-1]+1                  IF:   i&gt;0,j&gt;0, a[i] = b[j]</p>
<p>dp[i,j] = max(dp[i-1][j],dp[i][j-1])      IF:   i&gt;0,j&gt;0, a[i] != b[j]</p>
<details>
  <summary>动态规划解决最长公共子串问题的C语言实现代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLSC</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j,<span class="keyword">char</span> *a, <span class="keyword">int</span> status[][N])</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">0</span> || j== <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (status[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">    printLSC(i<span class="number">-1</span>,j<span class="number">-1</span>,a,status);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (status[i][j] == <span class="number">1</span>)</span><br><span class="line">      printLSC(i<span class="number">-1</span>,j,a,status);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      printLSC(i,j<span class="number">-1</span>,a,status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> a[] = &#123;<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> b[] = &#123;<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;A&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> status[M][N]; <span class="comment">//保存状态</span></span><br><span class="line">  <span class="keyword">int</span> dp[M][N];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      dp[i][j] = <span class="number">0</span>;</span><br><span class="line">      status[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] == b[j])&#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        status[i][j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>] &gt;= dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">        dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">        status[i][j] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        status[i][j] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;最大长度：%d&quot;</span>,dp[M<span class="number">-1</span>][N<span class="number">-1</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  printLSC(M<span class="number">-1</span>,N<span class="number">-1</span>,a,status);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3><span id="最长递增子序列lis"> 最长递增子序列(LIS)</span></h3>
<p>给定一个序列 An = a1 ,a2 ,  … , an,找出最长的子序列使得对所有 i &lt; j,ai &lt; aj 。</p>
<p>转移方程：b[k]=max(max(b[j]|a[j]&lt;a[k],j&lt;k)+1,1);</p>
<details>
  <summary>动态规划解决最长递增子序列问题的C语言实现代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,length,max=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-5</span>,<span class="number">6</span>,<span class="number">-7</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">int</span> *b;</span><br><span class="line">  b = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(a));</span><br><span class="line">  length = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">    b[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i] &gt; a[j] &amp;&amp; b[i] &lt;= b[j])&#123;</span><br><span class="line">        b[i] = b[j] + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    <span class="keyword">if</span>(b[i] &gt; max)</span><br><span class="line">      max = b[i];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h3><span id="最大连续子序列之和"> 最大连续子序列之和</span></h3>
<p>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序中元素和最大的一个， 例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和为20。</p>
<p>状态转移方程： sum[i]=max(sum[i-1]+a[i],a[i])</p>
<details>
  <summary>动态规划解决最大连续子序列问题的C语言实现代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">int</span> i,sum = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> data[] = &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data)/<span class="keyword">sizeof</span>(data[<span class="number">0</span>]); i++)&#123;</span><br><span class="line">    sum += data[i];</span><br><span class="line">    <span class="keyword">if</span>(sum &gt; max)</span><br><span class="line">      max = sum;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h3><span id="01背包问题"> 01背包问题</span></h3>
<p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
<p>转移方程：dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i]</p>
<details>
  <summary>动态规划解决01背包问题的C语言实现代码</summary>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#define max(a,b) ((a)&gt;(b)?(a):(b))</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  int v = 10 ;</span><br><span class="line">  int n = 5 ;</span><br><span class="line"></span><br><span class="line">  int value[] = &#123;0, 8 , 10 , 4 , 5 , 5&#125;;</span><br><span class="line">  int weight[] = &#123;0, 6 , 4 , 2 , 4 , 3&#125;;</span><br><span class="line">  int i,j;</span><br><span class="line">  int dp[n+1][v+1];</span><br><span class="line">  for(i = 0; i &lt; n+1; i++)</span><br><span class="line">    for(j = 0; j &lt; v+1; j++)</span><br><span class="line">      dp[i][j] = 0;</span><br><span class="line"></span><br><span class="line">  for (i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">    for (j = 1; j &lt;= v; j++)&#123;</span><br><span class="line">      if (j &gt;= weight[i])</span><br><span class="line">        dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i]);</span><br><span class="line">      else</span><br><span class="line">        dp[i][j] = dp[i-1][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;%d&quot;,dp[n][v]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3><span id="青蛙跳台阶问题"> 青蛙跳台阶问题</span></h3>
<p>一只青蛙可以一次跳一级台阶，也可以一次跳两级台阶，如果青蛙要跳上n级台阶，共有多少钟跳法？</p>
<p>当青蛙即将跳上n级台阶时，共有两种可能性，一种是从n-1级台阶跳一步到n级，另外一种是从n-2级台阶跳两步到n级，所以求到n级台阶的所有可能性f(n)就转变为了求到n-2级台阶的所有可能性f(n-2)和到n-1级台阶的所有可能性f(n-1)之和，以此类推至最后f(2)=f(0)+f(1)=1+1。递推公式就是f(n) = f(n - 1) + f(n - 2)</p>
<details>
  <summary>动态规划解决青蛙跳台阶问题的C语言实现代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      <span class="comment">//递推公式f(n) = f(n - 1) + f(n -2)</span></span><br><span class="line">      dp[<span class="number">2</span>] = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">      dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Fibonacci fb = <span class="keyword">new</span> Fibonacci();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.print(fb.fibonacci(i));</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<blockquote>
<p>相关题目 – 青蛙变态跳台阶问题<br>
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法？</p>
</blockquote>
<h3><span id="收集苹果"> 收集苹果</span></h3>
<p>平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始，每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来，这样下去，你最多能收集到多少个苹果。</p>
<blockquote>
<p>输入: 第一行输入行数和列数, 然后逐行输入每个格子的中的苹果的数量</p>
</blockquote>
<blockquote>
<p>输出：最多能收到的苹果的个数。</p>
</blockquote>
<p>这是一个典型的二维数组DP问题</p>
<ul>
<li>
<p>基本状态：<br>
当你到达第x行第y列的格子的时候，收集到的苹果的数量dp[x][y]。</p>
</li>
<li>
<p>转移方程：<br>
由于你只能向右走或者向下走，所以当你到达第x行第y列的格子的时候，你可能是从第x-1行第y列或者第x行第y-1列到达该格子的，而我们最后只要收集苹果最多的那一种方案。所以：<br>
dp[x][y] = max( if(x&gt;0) dp[x-1][y] , if(y&gt;0) dp[x][y-1])</p>
</li>
</ul>
<details>
  <summary>动态规划解决收集苹果问题的C语言实现代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp_fun</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  dp[x][y] = a[x][y];</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; max &lt; dp[x<span class="number">-1</span>][y]) &#123;</span><br><span class="line">    max = dp[x<span class="number">-1</span>][y];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(y &gt; <span class="number">0</span> &amp;&amp; max &lt; dp[x][y<span class="number">-1</span>]) &#123;</span><br><span class="line">    max = dp[x][y<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  dp[x][y] += max;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;m<span class="number">-1</span>) &#123;</span><br><span class="line">    dp_fun(x+<span class="number">1</span>,y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(y&lt;n<span class="number">-1</span>) &#123;</span><br><span class="line">    dp_fun(x,y+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dp_fun(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;dp[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h3><span id="数塔取数问题"> 数塔取数问题</span></h3>
<p>一个高度为N的由正整数组成的三角形，从上走到下，求经过的数字和的最大值。每次只能走到下一层相邻的数上，例如从第3层的6向下走，只能走到第4层的2或9上。<br>
5</p>
<p>8 4</p>
<p>3 6 9</p>
<p>7 2 9 5</p>
<p>例子中的最优方案是：5 + 8 + 6 + 9 = 28。</p>
<p>站在位置9，我们可以选择沿12方向移动，也可以选择沿着15方向移动，现在我们假设“已经求的”沿12方向的最大值x和沿15方向的最大值y，那么站在9的最大值必然是：Max(x,y) + 9。</p>
<p>因此不难得出，对于任意节点i,其状态转移方程为：m[i] = Max(a[i的左孩子] , a[i的右孩子]) + a[i]</p>
<p>首先什么是“数塔类型”？从某一点转向另一点或者说是从某一状态转向另一状态，有多种选择方式(比如这里的9-&gt;12 , 9-&gt;15)，从中选取一条能产生最优值的路径。</p>
<p>这类问题的思考方法：假设后续步骤的结果已知，比如这里假设已经知道沿12方向的最大值x和沿15方向的最大值y。</p>
<details>
  <summary>动态规划解决数塔取数问题的C语言实现代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>    <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>        N    10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>        Max(a,b)    ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>     a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>        n , m , i , k , j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        k = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        k = k - n;</span><br><span class="line">        <span class="keyword">for</span>(i = k , j = <span class="number">0</span> ; i &gt;= <span class="number">1</span> ; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = a[i] + Max(a[i+n],a[i+n<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(++j == n <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n--;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>    <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3><span id="免费馅饼问题"> 免费馅饼问题</span></h3>
<p>都说天上不会掉馅饼，但有一天gameboy正走在回家的小径上，忽然天上掉下大把大把的馅饼。说来gameboy的人品实在是太好了，这馅饼别处都不掉，就掉落在他身旁的10米范围内。馅饼如果掉在了地上当然就不能吃了，所以gameboy马上卸下身上的背包去接。但由于小径两侧都不能站人，所以他只能在小径上接。由于gameboy平时老呆在房间里玩游戏，虽然在游戏中是个身手敏捷的高手，但在现实中运动神经特别迟钝，每秒种只有在移动不超过一米的范围内接住坠落的馅饼。现在给这条小径如图标上坐标：</p>
<p>为了使问题简化，假设在接下来的一段时间里，馅饼都掉落在0-10这11个位置。开始时gameboy站在5这个位置，因此在第一秒，他只能接到4,5,6这三个位置中期中一个位置上的馅饼。问gameboy最多可能接到多少个馅饼？(假设他的背包可以容纳无穷多个馅饼)</p>
<blockquote>
<p>Input： 输入数据有多组。每组数据的第一行为以正整数n(0&lt;n&lt;100000)，表示有n个馅饼掉在这条小径上。在结下来的n行中，每行有两个整数x,T(0&lt;T&lt;100000),表示在第T秒有一个馅饼掉在x点上。同一秒钟在同一点上可能掉下多个馅饼。n=0时输入结束。</p>
</blockquote>
<blockquote>
<p>Output： 每一组输入数据对应一行输出。输出一个整数m，表示gameboy最多可能接到m个馅饼。</p>
</blockquote>
<blockquote>
<p>提示：本题的输入数据量比较大，建议用scanf读入，用cin可能会超时。</p>
</blockquote>
<blockquote>
<p>Sample Input： 6 5 1 4 1 6 1 7 2 7 2 8 3 0</p>
</blockquote>
<blockquote>
<p>Sample Output： 4</p>
</blockquote>
<p>类似于DP中的数塔，不过要倒过来算，从下往上算，最后输出初始位置的数即可， 为了便于判断边界，可以将数组宽度开大一些，让它从1~11计数，这样就不用单独计算边界了， 如果数塔不懂，可以看我之前发的经典数塔题。</p>
<details>
  <summary>动态规划解决免费馅饼问题的C语言实现代码</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ARRAY_SIZE 100000</span></span><br><span class="line"><span class="keyword">int</span> data[MAX_ARRAY_SIZE][<span class="number">11</span>];<span class="comment">//存放最初的数据</span></span><br><span class="line"><span class="keyword">int</span> cost[MAX_ARRAY_SIZE][<span class="number">11</span>];<span class="comment">//存放各个子问题的最优解</span></span><br><span class="line"><span class="keyword">int</span> mark[MAX_ARRAY_SIZE][<span class="number">11</span>];<span class="comment">//存放输出最优解方案标志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n),n!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="keyword">int</span> i,x,T,max_T=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化data</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;T);</span><br><span class="line">      <span class="keyword">if</span>(T&gt;max_T)</span><br><span class="line">        max_T=T;</span><br><span class="line">      data[T][x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp初始化</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)&#123;</span><br><span class="line">      cost[max_T][i]=data[max_T][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp过程</span></span><br><span class="line">    <span class="keyword">for</span>(i=max_T<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">      <span class="keyword">int</span> j;</span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">11</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> lvalue,mvalue,rvalue,maxvalue;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">          lvalue=<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          lvalue=cost[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        mvalue=data[i+<span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">10</span>)&#123;</span><br><span class="line">          rvalue=<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          rvalue=cost[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lvalue&gt;mvalue)&#123;</span><br><span class="line">          maxvalue=lvalue;</span><br><span class="line">          mark[i][j]=<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(mvalue&gt;rvalue)&#123;</span><br><span class="line">            maxvalue=mvalue;</span><br><span class="line">            mark[i][j]=<span class="number">0</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxvalue=rvalue;</span><br><span class="line">            mark[i][j]=<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cost[i][j]=data[i][j]+maxvalue;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cost[<span class="number">0</span>][<span class="number">5</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details><!-- lincense--><div class="license-wrapper"><p><span>文章作者:</span><a href="https://imzhanghao.com">ZhangHao</a></p><p><span>文章链接:</span><a href="https://imzhanghao.com/2020/04/25/5-classic-algorithms-4-dynamic-programming/">https://imzhanghao.com/2020/04/25/5-classic-algorithms-4-dynamic-programming/</a></p><p><span>版权声明:</span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4128258433761966" data-ad-slot="1528926940" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><hr><p><span>↶ </span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap.min.js"></script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script></body></html>