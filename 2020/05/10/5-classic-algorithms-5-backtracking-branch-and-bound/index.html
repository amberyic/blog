<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="keywords" content="回溯法,分支界定法,迷宫问题,01背包问题,八皇后问题,幂集,子集和问题"><meta name="description" content="本文讲解回溯法和分支界定法的概念、基本思路，以及在经典问题中的实际应用，配合代码，直观明了。"><meta name="author" content="ZhangHao"><meta name="viewport" content="width=device-width, initial-scale=0.5"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><title>五大经典算法|5.回溯法&amp;分支界定法 - 张浩在路上</title><link rel="icon" href="/img/favicon.ico"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="dns-prefetch" href="https://hm.baidu.com"><script src="https://www.googletagmanager.com/gtag/js?id=UA-166608124-1" async=""></script><script>if (window.location.hostname !== 'localhost') {
  window.dataLayer = window.dataLayer || [];
  function gtag(){ dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-166608124-1');
}</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement('script');
  hm.src = 'https://hm.baidu.com/hm.js?0c64a5657309290fd8f5efe33fcbcdb4';
  hm.async = true;

  var s = document.getElementsByTagName('script')[0];
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/header.css"><link rel="icon" href="/img/favicon.png"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="张浩在路上" type="application/atom+xml">
</head><body>　　<nav class="navbar navbar-default navbar-fixed-top" style="opacity:.9;" role="navigation"><div class="container-fluid"><div class="navbar-header"><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/" _blank>张浩在路上</a></div><div class="navbar-collapse collapse" id="bs-example-navbar-collapse-1" style="height:1px;"><ul class="nav navbar-nav navbar-right"><li><a href="/" target="_self">首页</a></li><li><a href="/technology" target="_self">技术</a></li><li><a href="/monetization" target="_self">变现</a></li><li><a href="/thinking" target="_self">思考</a></li><li><a href="/about" target="_self">关于</a></li></ul></div></div></nav><div class="inner"><h1>五大经典算法|5.回溯法&amp;分支界定法</h1><div id="toc"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text"> 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text"> 思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text"> 经典例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text"> 迷宫问题(maze problem)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.2.</span> <span class="toc-text"> 01背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.3.</span> <span class="toc-text"> 八皇后问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.4.</span> <span class="toc-text"> 幂集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">3.5.</span> <span class="toc-text"> 子集和问题</span></a></li></ol></li></ol></div><p>这个部分在我们的课程中主要是在树及图的深度广度搜索部分有涉及，另外迷宫问题求解也有涉及。</p>
<p>经典例题: 迷宫问题(maze problem),01背包问题,八皇后问题,幂集,子集和问题</p>
<h2><span id="概念"> 概念</span></h2>
<p>回溯法</p>
<ul>
<li>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</li>
<li>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</li>
<li>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</li>
</ul>
<p>分支界定法</p>
<ul>
<li>类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</li>
</ul>
<h2><span id="思想"> 思想</span></h2>
<p>回溯法</p>
<ul>
<li>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。(其实回溯法就是对隐式图的深度优先搜索算法)。</li>
<li>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</li>
<li>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</li>
</ul>
<p>分支界定法</p>
<p>分支搜索算法, 所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p>
<ul>
<li>FIFO搜索</li>
<li>LIFO搜索</li>
<li>优先队列式搜索</li>
</ul>
<h2><span id="经典例题"> 经典例题</span></h2>
<h3><span id="迷宫问题maze-problem"> 迷宫问题(maze problem)</span></h3>
<p>给定一个迷宫，指明起点和终点，找出从起点出发到终点的有效可行路径，就是迷宫问题(maze problem)</p>
<p>迷宫可以以二维数组来存储表示。0表示通路，1表示障碍。注意这里规定移动可以从上、下、左、右四方方向移动。坐标以行和列表示，均从0开始，给定起点(0,0)和终点(4,4)，迷宫表示如下：</p>
<p>int maze[5][5]={</p>
<pre><code> &#123;0,0,0,0,0&#125;,

 &#123;0,1,0,1,0&#125;,

 &#123;0,1,1,0,0&#125;,

 &#123;0,1,1,0,1&#125;,

 &#123;0,0,0,0,0&#125;
</code></pre>
<p>};</p>
<p>那么下面的迷宫就有两条可行的路径，分别为：</p>
<p>(1) (0,0) (0,1) (0,2) (0,3) (0,4) (1,4) (2,4) (2,3) (3,3) (4,3) (4,4)；</p>
<p>(2) (0,0) (1,0) (2,0) (3,0) (4,0) (4,1) (4,2) (4,3) (4,4) ；</p>
<p>可见，迷宫可行路径有可能是多条，且路径长度可能不一。</p>
<p>迷宫问题的求解可以抽象为连通图的遍历，因此主要有两种方法。</p>
<ul>
<li>
<p>第一种方法是：深度优先搜索(DFS)加回溯。</p>
<ul>
<li>优点：无需像广度优先搜索那样(BFS)记录前驱结点。</li>
<li>缺点：找到的第一条可行路径不一定是最短路径，如果需要找到最短路径，那么需要找出所有可行路径后，再逐一比较，求出最短路径。</li>
</ul>
</li>
<li>
<p>第二种方法是：广度优先搜索(BFS)。</p>
<ul>
<li>优点：找出的第一条路径就是最短路径。</li>
<li>缺点：需要记录结点的前驱结点，来形成路径。</li>
</ul>
</li>
</ul>
<details>
  <summary>方法一：深度优先搜索(DFS)加回溯求解第一条可行路径</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">实现步骤</span><br><span class="line">(<span class="number">1</span>)给定起点和终点，判断二者的合法性，如果不合法，返回；</span><br><span class="line">(<span class="number">2</span>)如果起点和终点合法，将起点入栈；</span><br><span class="line">(<span class="number">3</span>)取栈顶元素，求其邻接的未被访问的无障碍结点。求如果有，记其为已访问，并入栈。</span><br><span class="line">   如果没有则回溯上一结点，具体做法是将当前栈顶元素出栈。</span><br><span class="line">   其中，求邻接无障碍结点的顺序可任意，本文实现是以上、右、下、左的顺序求解。</span><br><span class="line">(<span class="number">4</span>)重复步骤(<span class="number">3</span>)，直到栈空(没有找到可行路径)或者栈顶元素等于终点(找到第一条可行路径)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="comment">//行与列</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;row=x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;col=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Point&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;row!=rhs.row||<span class="keyword">this</span>-&gt;col!=rhs.col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func:获取相邻未被访问的节点</span></span><br><span class="line"><span class="comment">//para:mark:结点标记，point：结点，m：行，n：列</span></span><br><span class="line"><span class="comment">//ret:邻接未被访问的结点</span></span><br><span class="line"><span class="function">Point <span class="title">getAdjacentNotVisitedNode</span><span class="params">(<span class="keyword">bool</span>** mark,Point point,<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">resP</span><span class="params">(<span class="number">-1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (point.row<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;mark[point.row<span class="number">-1</span>][point.col]==<span class="literal">false</span>)&#123;<span class="comment">//上节点满足条件</span></span><br><span class="line">        resP.row=point.row<span class="number">-1</span>;</span><br><span class="line">        resP.col=point.col;</span><br><span class="line">        <span class="keyword">return</span> resP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (point.col+<span class="number">1</span>&lt;n&amp;&amp;mark[point.row][point.col+<span class="number">1</span>]==<span class="literal">false</span>)&#123;<span class="comment">//右节点满足条件</span></span><br><span class="line">        resP.row=point.row;</span><br><span class="line">        resP.col=point.col+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> resP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (point.row+<span class="number">1</span>&lt;m&amp;&amp;mark[point.row+<span class="number">1</span>][point.col]==<span class="literal">false</span>)&#123;<span class="comment">//下节点满足条件</span></span><br><span class="line">        resP.row=point.row+<span class="number">1</span>;</span><br><span class="line">        resP.col=point.col;</span><br><span class="line">        <span class="keyword">return</span> resP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (point.col<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;mark[point.row][point.col<span class="number">-1</span>]==<span class="literal">false</span>)&#123;<span class="comment">//左节点满足条件</span></span><br><span class="line">        resP.row=point.row;</span><br><span class="line">        resP.col=point.col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> resP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func：给定二维迷宫，求可行路径</span></span><br><span class="line"><span class="comment">//para:maze：迷宫；m：行；n：列；startP：开始结点 endP：结束结点； pointStack：栈，存放路径结点</span></span><br><span class="line"><span class="comment">//ret:无</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mazePath</span><span class="params">(<span class="keyword">void</span>* maze,<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">const</span> Point&amp; startP,Point endP,<span class="built_in">stack</span>&lt;Point&gt;&amp; pointStack)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将给定的任意列数的二维数组还原为指针数组，以支持下标操作</span></span><br><span class="line">    <span class="keyword">int</span>** maze2d=<span class="keyword">new</span> <span class="keyword">int</span>*[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        maze2d[i]=(<span class="keyword">int</span>*)maze+i*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maze2d[startP.row][startP.col]==<span class="number">1</span>||maze2d[endP.row][endP.col]==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ;                    <span class="comment">//输入错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立各个节点访问标记</span></span><br><span class="line">    <span class="keyword">bool</span>** mark=<span class="keyword">new</span> <span class="keyword">bool</span>*[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        mark[i]=<span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">            mark[i][j]=*((<span class="keyword">int</span>*)maze+i*n+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将起点入栈</span></span><br><span class="line">    pointStack.push(startP);</span><br><span class="line">    mark[startP.row][startP.col]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈不空并且栈顶元素不为结束节点</span></span><br><span class="line">    <span class="keyword">while</span>(pointStack.empty()==<span class="literal">false</span>&amp;&amp;pointStack.top()!=endP)&#123;</span><br><span class="line">        Point adjacentNotVisitedNode=getAdjacentNotVisitedNode(mark,pointStack.top(),m,n);</span><br><span class="line">        <span class="keyword">if</span> (adjacentNotVisitedNode.row==<span class="number">-1</span>)&#123; <span class="comment">//没有未被访问的相邻节点</span></span><br><span class="line">            pointStack.pop(); <span class="comment">//回溯到上一个节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//入栈并设置访问标志为true</span></span><br><span class="line">        mark[adjacentNotVisitedNode.row][adjacentNotVisitedNode.col]=<span class="literal">true</span>;</span><br><span class="line">        pointStack.push(adjacentNotVisitedNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maze[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">startP</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">endP</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Point&gt;  pointStack;</span><br><span class="line">    mazePath(maze,<span class="number">5</span>,<span class="number">5</span>,startP,endP,pointStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找打可行解</span></span><br><span class="line">    <span class="keyword">if</span> (pointStack.empty()==<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no right path&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;Point&gt; tmpStack;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;path:&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(pointStack.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">            tmpStack.push(pointStack.top());</span><br><span class="line">            pointStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (tmpStack.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,tmpStack.top().row,tmpStack.top().col);</span><br><span class="line">            tmpStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序输出：path:(<span class="number">0</span>,<span class="number">0</span>) (<span class="number">0</span>,<span class="number">1</span>) (<span class="number">0</span>,<span class="number">2</span>) (<span class="number">0</span>,<span class="number">3</span>) (<span class="number">0</span>,<span class="number">4</span>) (<span class="number">1</span>,<span class="number">4</span>) (<span class="number">2</span>,<span class="number">4</span>) (<span class="number">2</span>,<span class="number">3</span>) (<span class="number">3</span>,<span class="number">3</span>) (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">4</span>,<span class="number">4</span>)。</span><br><span class="line"></span><br><span class="line">可见该条路径不是最短路径。因为程序中给定的迷宫还有一条更短路径为：(<span class="number">0</span>,<span class="number">0</span>) (<span class="number">1</span>,<span class="number">0</span>) (<span class="number">2</span>,<span class="number">0</span>) (<span class="number">3</span>,<span class="number">0</span>) (<span class="number">4</span>,<span class="number">0</span>) (<span class="number">4</span>,<span class="number">1</span>) (<span class="number">4</span>,<span class="number">2</span>) (<span class="number">4</span>,<span class="number">3</span>) (<span class="number">4</span>,<span class="number">4</span>) ；</span><br></pre></td></tr></table></figure>
</details>
<details>
  <summary>方法二：改进深度优先搜索(DFS)加回溯求解最短路径</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">实现方法</span><br><span class="line">根据上面的方法我们可以在此基础之上进行改进，求出迷宫的最短的路径。具体做法如下：</span><br><span class="line">(<span class="number">1</span>)让已经访问过的结点可以再次被访问，具体做法是将mark标记改为当前结点到起点的距离，作为当前结点的权值。即从起点开始出发，向四个方向查找，每走一步，把走过的点的值+<span class="number">1</span>；</span><br><span class="line">(<span class="number">2</span>)寻找栈顶元素的下一个可访问的相邻结点，条件就是栈顶元素的权值加<span class="number">1</span>必须小于下一个节点的权值(墙不能走，未被访问的结点权值为<span class="number">0</span>)；</span><br><span class="line">(<span class="number">3</span>)如果访问到终点，记录当前最短的路径。如果不是，则继续寻找下一个结点；</span><br><span class="line">(<span class="number">4</span>)重复步骤(<span class="number">2</span>)和(<span class="number">3</span>)直到栈空(迷宫中所有符合条件的结点均被访问)。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="comment">//行与列</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;row=x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;col=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Point&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;row!=rhs.row||<span class="keyword">this</span>-&gt;col!=rhs.col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;row==rhs.row&amp;&amp;<span class="keyword">this</span>-&gt;col==rhs.col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">-1</span>, <span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func:获取相邻未被访问的节点</span></span><br><span class="line"><span class="comment">//para:mark:结点标记；point：结点；m：行；n：列;endP:终点</span></span><br><span class="line"><span class="comment">//ret:邻接未被访问的结点</span></span><br><span class="line"><span class="function">Point <span class="title">getAdjacentNotVisitedNode</span><span class="params">(<span class="keyword">int</span>** mark,Point point,<span class="keyword">int</span> m,<span class="keyword">int</span> n,Point endP)</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">resP</span><span class="params">(<span class="number">-1</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (point.row<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[point.row<span class="number">-1</span>][point.col]==<span class="number">0</span>||mark[point.row][point.col]+<span class="number">1</span>&lt;mark[point.row<span class="number">-1</span>][point.col])&#123;<span class="comment">//上节点满足条件</span></span><br><span class="line">            resP.row=point.row<span class="number">-1</span>;</span><br><span class="line">            resP.col=point.col;</span><br><span class="line">            <span class="keyword">return</span> resP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (point.col+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[point.row][point.col+<span class="number">1</span>]==<span class="number">0</span>||mark[point.row][point.col]+<span class="number">1</span>&lt;mark[point.row][point.col+<span class="number">1</span>])&#123;<span class="comment">//右节点满足条件</span></span><br><span class="line">            resP.row=point.row;</span><br><span class="line">            resP.col=point.col+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> resP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (point.row+<span class="number">1</span>&lt;m)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[point.row+<span class="number">1</span>][point.col]==<span class="number">0</span>||mark[point.row][point.col]+<span class="number">1</span>&lt;mark[point.row+<span class="number">1</span>][point.col])&#123;<span class="comment">//下节点满足条件</span></span><br><span class="line">            resP.row=point.row+<span class="number">1</span>;</span><br><span class="line">            resP.col=point.col;</span><br><span class="line">            <span class="keyword">return</span> resP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (point.col<span class="number">-1</span>&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (mark[point.row][point.col<span class="number">-1</span>]==<span class="number">0</span>||mark[point.row][point.col]+<span class="number">1</span>&lt;mark[point.row][point.col<span class="number">-1</span>])&#123;<span class="comment">//左节点满足条件</span></span><br><span class="line">            resP.row=point.row;</span><br><span class="line">            resP.col=point.col<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> resP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func：给定二维迷宫，求可行路径</span></span><br><span class="line"><span class="comment">//para:maze：迷宫；m：行；n：列；startP：开始结点 endP：结束结点； pointStack：栈，存放路径结点;vecPath:存放最短路径</span></span><br><span class="line"><span class="comment">//ret:无</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mazePath</span><span class="params">(<span class="keyword">void</span>* maze,<span class="keyword">int</span> m,<span class="keyword">int</span> n, Point&amp; startP, Point endP,<span class="built_in">stack</span>&lt;Point&gt;&amp; pointStack,<span class="built_in">vector</span>&lt;Point&gt;&amp; vecPath)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将给定的任意列数的二维数组还原为指针数组，以支持下标操作</span></span><br><span class="line">    <span class="keyword">int</span>** maze2d=<span class="keyword">new</span> <span class="keyword">int</span>*[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        maze2d[i]=(<span class="keyword">int</span>*)maze+i*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maze2d[startP.row][startP.col]==<span class="number">-1</span>||maze2d[endP.row][endP.col]==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ;                    <span class="comment">//输入错误</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立各个节点访问标记，表示结点到到起点的权值，也记录了起点到当前结点路径的长度</span></span><br><span class="line">    <span class="keyword">int</span>** mark=<span class="keyword">new</span> <span class="keyword">int</span>*[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        mark[i]=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">            mark[i][j]=*((<span class="keyword">int</span>*)maze+i*n+j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startP==endP)&#123;<span class="comment">//起点等于终点</span></span><br><span class="line">        vecPath.push_back(startP);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加一个终点的已被访问的前驱结点集</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; visitedEndPointPreNodeVec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将起点入栈</span></span><br><span class="line">    pointStack.push(startP);</span><br><span class="line">    mark[startP.row][startP.col]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//栈不空并且栈顶元素不为结束节点</span></span><br><span class="line">    <span class="keyword">while</span>(pointStack.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">        Point adjacentNotVisitedNode=getAdjacentNotVisitedNode(mark,pointStack.top(),m,n,endP);</span><br><span class="line">        <span class="keyword">if</span> (adjacentNotVisitedNode.row==<span class="number">-1</span>)&#123; <span class="comment">//没有符合条件的相邻节点</span></span><br><span class="line">            pointStack.pop(); <span class="comment">//回溯到上一个节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adjacentNotVisitedNode==endP)&#123;<span class="comment">//以较短的路劲，找到了终点,</span></span><br><span class="line">            mark[adjacentNotVisitedNode.row][adjacentNotVisitedNode.col]=mark[pointStack.top().row][pointStack.top().col]+<span class="number">1</span>;</span><br><span class="line">            pointStack.push(endP);</span><br><span class="line">            <span class="built_in">stack</span>&lt;Point&gt; pointStackTemp=pointStack;</span><br><span class="line">            vecPath.clear();</span><br><span class="line">            <span class="keyword">while</span> (pointStackTemp.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">                vecPath.push_back(pointStackTemp.top());<span class="comment">//这里vecPath存放的是逆序路径</span></span><br><span class="line">                pointStackTemp.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            pointStack.pop(); <span class="comment">//将终点出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入栈并设置访问标志为true</span></span><br><span class="line">        mark[adjacentNotVisitedNode.row][adjacentNotVisitedNode.col]=mark[pointStack.top().row][pointStack.top().col]+<span class="number">1</span>;</span><br><span class="line">        pointStack.push(adjacentNotVisitedNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">startP</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">endP</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Point&gt;  pointStack;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; vecPath;</span><br><span class="line">    mazePath(maze,<span class="number">5</span>,<span class="number">5</span>,startP,endP,pointStack,vecPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vecPath.empty()==<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no right path&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;shortest path:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i=vecPath.rbegin();i!=vecPath.rend();++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,i-&gt;row,i-&gt;col);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<details>
  <summary>方法三: 广度优先搜索(BFS)求解迷宫的最短路径</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">广度优先搜索的优点是找出的第一条路径就是最短路径，所以经常用来搜索最短路径，思路和图的广度优先遍历一样，需要借助于队列。</span><br><span class="line">具体步骤：</span><br><span class="line">(<span class="number">1</span>)从入口元素开始，判断它上下左右的邻边元素是否满足条件，如果满足条件就入队列；</span><br><span class="line">(<span class="number">2</span>)取队首元素并出队列。寻找其相邻未被访问的元素，将其如队列并标记元素的前驱节点为队首元素。</span><br><span class="line">(<span class="number">3</span>)重复步骤(<span class="number">2</span>)，直到队列为空(没有找到可行路径)或者找到了终点。最后从终点开始，根据节点的前驱节点找出一条最短的可行路径。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="comment">//行与列</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    Point()&#123;</span><br><span class="line">        row=col=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;row=x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;col=y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Point&amp; rhs) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;row==rhs.row&amp;&amp;<span class="keyword">this</span>-&gt;col==rhs.col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maze[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mazePath</span><span class="params">(<span class="keyword">void</span>* maze,<span class="keyword">int</span> m,<span class="keyword">int</span> n, Point&amp; startP, Point endP,<span class="built_in">vector</span>&lt;Point&gt;&amp; shortestPath)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** maze2d=<span class="keyword">new</span> <span class="keyword">int</span>*[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        maze2d[i]=(<span class="keyword">int</span>*)maze+i*n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maze2d[startP.row][startP.col]==<span class="number">1</span>||maze2d[startP.row][startP.col]==<span class="number">1</span>) <span class="keyword">return</span> ; <span class="comment">//输入错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startP==endP)&#123; <span class="comment">//起点即终点</span></span><br><span class="line">        shortestPath.push_back(startP);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mark标记每一个节点的前驱节点，如果没有则为(-1，-1)，如果有，则表示已经被访问</span></span><br><span class="line">    Point** mark=<span class="keyword">new</span> Point*[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        mark[i]=<span class="keyword">new</span> Point[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;Point&gt; queuePoint;</span><br><span class="line">    queuePoint.push(startP);</span><br><span class="line">    <span class="comment">//将起点的前驱节点设置为自己</span></span><br><span class="line">    mark[startP.row][startP.col]=startP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(queuePoint.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">        Point pointFront=queuePoint.front();</span><br><span class="line">        queuePoint.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pointFront.row<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; maze2d[pointFront.row<span class="number">-1</span>][pointFront.col]==<span class="number">0</span>)&#123;<span class="comment">//上节点连通</span></span><br><span class="line">            <span class="keyword">if</span> (mark[pointFront.row<span class="number">-1</span>][pointFront.col]==Point())&#123;<span class="comment">//上节点未被访问，满足条件，如队列</span></span><br><span class="line">                mark[pointFront.row<span class="number">-1</span>][pointFront.col]=pointFront;</span><br><span class="line">                queuePoint.push(Point(pointFront.row<span class="number">-1</span>,pointFront.col)); <span class="comment">//入栈</span></span><br><span class="line">                <span class="keyword">if</span> (Point(pointFront.row<span class="number">-1</span>,pointFront.col)==endP)&#123; <span class="comment">//找到终点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pointFront.col+<span class="number">1</span>&lt;n &amp;&amp; maze2d[pointFront.row][pointFront.col+<span class="number">1</span>]==<span class="number">0</span>)&#123;<span class="comment">//右节点连通</span></span><br><span class="line">            <span class="keyword">if</span> (mark[pointFront.row][pointFront.col+<span class="number">1</span>]==Point())&#123;<span class="comment">//右节点未被访问，满足条件，如队列</span></span><br><span class="line">                mark[pointFront.row][pointFront.col+<span class="number">1</span>]=pointFront;</span><br><span class="line">                queuePoint.push(Point(pointFront.row,pointFront.col+<span class="number">1</span>));    <span class="comment">//入栈</span></span><br><span class="line">                <span class="keyword">if</span> (Point(pointFront.row,pointFront.col+<span class="number">1</span>)==endP)&#123; <span class="comment">//找到终点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pointFront.row+<span class="number">1</span>&lt;m &amp;&amp; maze2d[pointFront.row+<span class="number">1</span>][pointFront.col]==<span class="number">0</span>)&#123;<span class="comment">//下节点连通</span></span><br><span class="line">            <span class="keyword">if</span> (mark[pointFront.row+<span class="number">1</span>][pointFront.col]==Point())&#123;<span class="comment">//下节点未被访问，满足条件，如队列</span></span><br><span class="line">                mark[pointFront.row+<span class="number">1</span>][pointFront.col]=pointFront;</span><br><span class="line">                queuePoint.push(Point(pointFront.row+<span class="number">1</span>,pointFront.col));    <span class="comment">//入栈</span></span><br><span class="line">                <span class="keyword">if</span> (Point(pointFront.row+<span class="number">1</span>,pointFront.col)==endP)&#123; <span class="comment">//找到终点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pointFront.col<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; maze2d[pointFront.row][pointFront.col<span class="number">-1</span>]==<span class="number">0</span>)&#123;<span class="comment">//左节点连通</span></span><br><span class="line">            <span class="keyword">if</span> (mark[pointFront.row][pointFront.col<span class="number">-1</span>]==Point())&#123;<span class="comment">//上节点未被访问，满足条件，如队列</span></span><br><span class="line">                mark[pointFront.row][pointFront.col<span class="number">-1</span>]=pointFront;</span><br><span class="line">                queuePoint.push(Point(pointFront.row,pointFront.col<span class="number">-1</span>));    <span class="comment">//入栈</span></span><br><span class="line">                <span class="keyword">if</span> (Point(pointFront.row,pointFront.col<span class="number">-1</span>)==endP)&#123; <span class="comment">//找到终点</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queuePoint.empty()==<span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> row=endP.row;</span><br><span class="line">        <span class="keyword">int</span> col=endP.col;</span><br><span class="line">        shortestPath.push_back(endP);</span><br><span class="line">        <span class="keyword">while</span>(!(mark[row][col]==startP))&#123;</span><br><span class="line">            shortestPath.push_back(mark[row][col]);</span><br><span class="line">            row=mark[row][col].row;</span><br><span class="line">            col=mark[row][col].col;</span><br><span class="line">        &#125;</span><br><span class="line">        shortestPath.push_back(startP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">startP</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">Point <span class="title">endP</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Point&gt; vecPath;</span><br><span class="line">    mazePath(maze,<span class="number">5</span>,<span class="number">5</span>,startP,endP,vecPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vecPath.empty()==<span class="literal">true</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no right path&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;shortest path:&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i=vecPath.rbegin();i!=vecPath.rend();++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,i-&gt;row,i-&gt;col);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<h3><span id="01背包问题"> 01背包问题</span></h3>
<p>给定N中物品和一个背包。物品i的重量是Wi,其价值位Vi ，背包的容量为C。问应该如何选择装入背包的物品，使得转入背包的物品的总价值为最大？？</p>
<p>0-1背包是子集合选取问题,一般情况下0-1背包是个NP问题.</p>
<ul>
<li>第一步　确定解空间：装入哪几种物品.</li>
<li>第二步　确定易于搜索的解空间结构： 可以用数组p,w分别表示各个物品价值和重量。用数组x记录，是否选种物品.</li>
<li>第三步　以深度优先的方式搜索解空间，并在搜索的过程中剪枝</li>
</ul>
<p>我们同样可以使用子集合问题的框架来写我们的代码，和前面子集和数问题相差无几。</p>
<details>
  <summary>动态规划解决01背包问题的C语言实现</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Knapsack(<span class="keyword">double</span> *pp,<span class="keyword">double</span> *ww,<span class="keyword">int</span> nn,<span class="keyword">double</span> cc)&#123;</span><br><span class="line">       p = pp;</span><br><span class="line">       w = ww;</span><br><span class="line">       n = nn;</span><br><span class="line">       c = cc;</span><br><span class="line">       cw = <span class="number">0</span>;</span><br><span class="line">       cp = <span class="number">0</span>;</span><br><span class="line">       bestp = <span class="number">0</span>;</span><br><span class="line">       x = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       cx = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">knapsack</span><span class="params">()</span></span>&#123;</span><br><span class="line">       backtrack(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//回溯法</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cp &gt; bestp)&#123;</span><br><span class="line">               bestp = cp;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">             x[i] = cx[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cw + w[i] &lt;= c)&#123;<span class="comment">//搜索右子树</span></span><br><span class="line">          cw += w[i];</span><br><span class="line">          cp += p[i];</span><br><span class="line">          cx[i] = <span class="number">1</span>;</span><br><span class="line">          backtrack(i+<span class="number">1</span>);</span><br><span class="line">          cw -= w[i];</span><br><span class="line">          cp -= p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cx[i] = <span class="number">0</span>;</span><br><span class="line">        backtrack(i+<span class="number">1</span>);<span class="comment">//搜索左子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;可以装入的最大价值为:&quot;</span> &lt;&lt; bestp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;装入的物品依次为:&quot;</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span> (x[i] == <span class="number">1</span>)</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">double</span> *p,*w;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">   <span class="keyword">double</span> c;</span><br><span class="line">   <span class="keyword">double</span> bestp,cp,cw;<span class="comment">//最大价值，当前价值，当前重量</span></span><br><span class="line">   <span class="keyword">int</span> *x,*cx;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">　　<span class="keyword">double</span> p[<span class="number">4</span>] = &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">7</span>,<span class="number">4</span>&#125;,w[<span class="number">4</span>] = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    Knapsack ks = Knapsack(p,w,<span class="number">4</span>,<span class="number">7</span>);</span><br><span class="line">    ks.knapsack();</span><br><span class="line">　　ks.printResult();</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3><span id="八皇后问题"> 八皇后问题</span></h3>
<p>八皇后问题是一个古老而著名的问题，是回溯算法的典型例题。该问题是十九世纪著名的数学家高斯1850年提出：在8X8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上.</p>
<ul>
<li>第一步 定义问题的解空间: 这个问题解空间就是8个皇后在棋盘中的位置.</li>
<li>第二步 定义解空间的结构: 可以使用8*8的数组，但由于任意两个皇后都不能在同行，我们可以用数组下标表示行，数组的值来表示皇后放的列，故可以简化为一个以维数组x[9]。</li>
<li>第三步 以深度优先的方式搜索解空间，并在搜索过程使用剪枝函数来剪枝</li>
</ul>
<details>
  <summary>动态规划解决八皇后问题的C语言实现</summary>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; x[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="comment">//判断处于同一列或同一斜线</span></span><br><span class="line">       <span class="keyword">if</span> (x[i] == x[k] || <span class="built_in">abs</span>(k-i) == <span class="built_in">abs</span>(x[k]-x[i]))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queen</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">8</span>)&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; j++)&#123;</span><br><span class="line">      x[i] = j;</span><br><span class="line">      <span class="keyword">if</span> (canPlace(i)) queen(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  queen(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3><span id="幂集"> 幂集</span></h3>
<p>幂集的每个元素是一个集合或者是一个空集。拿集合{A, B, C}来举例，这个集合的幂集为{ {A, B, C}, {A , B}, {A , C}, {B, C},{A}, {B}, {C}, {}}。可以看出分为3中状态:</p>
<ul>
<li>1.空集</li>
<li>2.是集合中的一个元素组成的集合</li>
<li>3.是集合中的任意两个元素组成的集合</li>
<li>4.是集合中的三个元素组成的集合，就是它本身</li>
</ul>
<p>算法思想，集合中每个元素有两种状态，在幂集元素的集合中，不在集合中。可以用一颗二叉树形象的表示回溯遍历的过程</p>
<details>
  <summary>动态规划解决幂集问题的C语言实现</summary>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char *result;</span><br><span class="line">char *element;</span><br><span class="line">void OutputPowerSet(int len)&#123; //输出幂集中的元素</span><br><span class="line">  cout&lt;&lt;&quot;&#123; &quot;;</span><br><span class="line">  int eln = 0;</span><br><span class="line">  for (int i = 0; i &lt; len; i++)&#123;</span><br><span class="line">    if (result[i] != 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (eln &gt; 0)</span><br><span class="line">        cout&lt;&lt;&quot;, &quot;&lt;&lt;result[i];</span><br><span class="line">      else</span><br><span class="line">        cout&lt;&lt;result[i];</span><br><span class="line">      eln++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;&quot; &#125;; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">void PowerSet(int k,int n)&#123;</span><br><span class="line">  if (k &gt; n)</span><br><span class="line">  &#123;</span><br><span class="line">    OutputPowerSet(n);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    result[k-1] = element[k-1]; //元素在幂集元素集合中</span><br><span class="line">    PowerSet(k+1,n);</span><br><span class="line">    result[k-1] = 0;//元素不在幂集元素集合中</span><br><span class="line">    PowerSet(k+1,n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">  int num;</span><br><span class="line">  cin&gt;&gt;num;    //输出要求幂集的初始集合元素个数</span><br><span class="line">  element = new char[num];</span><br><span class="line">  result = new char[num];</span><br><span class="line">  int index = 0;</span><br><span class="line">  while(index &lt; num)&#123;</span><br><span class="line">    cin&gt;&gt;element[index];  //输入集合元素，这里用字符代替</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  PowerSet(1,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3><span id="子集和问题"> 子集和问题</span></h3>
<p>存在S={x1,x2,…xn}.是一个正整数的集合，c是一个正整数。子集合问题判定是否存在一个子集S1(S1为S的子集)，使得该子集的和为c.</p>
<p>例子：S={1,3,8,9},C=9,则解为:s1={1,8},s2={9}</p>
<p>可以看出此算法的解空间为子集树，所以利用前面讲的模板，可以得到哦以下程序</p>
<details>
  <summary>动态规划解决子集和问题的C语言实现</summary>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">bool next(int a[],int n, int i, int s, int r, int c, int bextx[], int x[])</span><br><span class="line">&#123;</span><br><span class="line">  int j;</span><br><span class="line">  if (i &gt;= n) &#123;//到达叶子结点</span><br><span class="line">    if (s == c) &#123; //找到一个子集</span><br><span class="line">      for (int k=0;k&lt;n;k++) &#123;//记录下子集</span><br><span class="line">        bextx[k] = x[k];</span><br><span class="line">      &#125;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;//没有找到符合的子集</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (s &gt;c || s+r &lt;c) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  x[i] = 1;</span><br><span class="line">  if (next(a, n, i+1, s+a[i], r-a[i], c, bextx, x)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  x[i] = 0;</span><br><span class="line">  return next(a, n, i+1, s, r-a[i], c, bextx, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool solve(int a[],int n,int c,int bextx[]) &#123;</span><br><span class="line">  //int *bextx = new int[n];</span><br><span class="line">  int *x = new int[n];</span><br><span class="line">  int r = 0;</span><br><span class="line">  for (int i=0; i&lt;n; i++) &#123;</span><br><span class="line">    r += a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return  next(a, n, 0, 0, r, c, bextx, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int a[]=&#123;1,2,6,8&#125;;</span><br><span class="line">  int n=4;</span><br><span class="line">  int c=8;</span><br><span class="line">  int *bextx = new int[n];</span><br><span class="line">  if (solve(a,n,c,bextx)) &#123;</span><br><span class="line">    printf(&quot;找到子集： \n\r&quot;);</span><br><span class="line">    for (int i=0;i&lt;n;i++) &#123;</span><br><span class="line">      printf(&quot;%d &quot;,bextx[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    printf(&quot;没有子集&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>
<!-- lincense--><div class="license-wrapper"><p><span>文章作者:</span><a href="https://imzhanghao.com">ZhangHao</a></p><p><span>文章链接:</span><a href="https://imzhanghao.com/2020/05/10/5-classic-algorithms-5-backtracking-branch-and-bound/">https://imzhanghao.com/2020/05/10/5-classic-algorithms-5-backtracking-branch-and-bound/</a></p><p><span>版权声明:</span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4128258433761966" data-ad-slot="1528926940" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});
</script><hr><p><span>↶ </span><a href="/">返回首页</a><span></span></p></div><script src="/js/jquery.min.js"></script><script src="/js/main.js"></script><script src="/js/bootstrap.min.js"></script><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" rel="stylesheet" type="text/css"><link href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.css" rel="stylesheet" type="text/css"><script src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/copy-tex.min.js"></script></body></html>